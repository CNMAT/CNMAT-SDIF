#ifndef SDIF_BOOLEANtypedef unsigned char Boolean;#undef TRUE#define TRUE 1#undef FALSE#define FALSE 0#define SDIF_BOOLEAN#endif#include <stdio.h>#include <stdlib.h>#include <stdarg.h>#include "sdif.h"#include "sdif-mem.h"#include "sdif-buf.h"#include "sdif-interp.h"#include "sdif-util.h"#include "sdif-unit.h"#include "sdif-unit-utils.h"//  parameters for running this teststatic const int NUM_FRAMES = 20;static const int NUM_COLUMNS = 2;static const int NUM_ROWS = 6;static const int FUN_DOMAIN = 100;static const int NUM_RANDOM_TIMES = 40;//  prototypes for entrypointsUnitTestFn unit_randomLinear1, unit_randomLinear2;//  prototypes for local functionsstatic SDIFresult doTest(SDIFinterp_InterpolatorFn interpFn);static SDIFresult doOneTest(SDIFinterp_InterpolatorFn interpFn);static SDIFresult doInterpolatorTest(SDIFbuf_Buffer buf, SDIFinterp_Interpolator it);static SDIFbuf_Buffer createRandomFunctionBuffer();static int createRandomFunction(SDIFbuf_Buffer b,                                sdif_int32 numFrames,                                const char *frameType,                                const char *matrixType,                                sdif_int32 columns,                                sdif_int32 rows,                                sdif_float64 functionDomain                                );static SDIFresult addJunkToBuffer(SDIFbuf_Buffer buf, int junkCount);static void randomTimeInit(void);static sdif_float64 randomTime(void);static sdif_float64 interpolateOneCell(SDIFbuf_Buffer buf,                                const char *matrixType,                                sdif_int32 column,                                sdif_int32 row,                                sdif_float64 time                                );static SDIFmem_Matrix doInterpolate(SDIFinterp_Interpolator it,                                     SDIFbuf_Buffer b,                                    const char *matrixType,                                    sdif_float64 time                                    );static SDIFinterp_Interpolator createInterpolator(SDIFinterp_InterpolatorFn interpFn);static SDIFinterp_InterpolatorFn unit_LinearInterpolator1;static SDIFinterp_InterpolatorFn unit_LinearInterpolator2;//  globalsstatic sdif_float64 randomTimeList[NUM_RANDOM_TIMES];//  implementation of unit test functionsvoid *unit_randomLinear1(SDIFunitCmd cmd, ...){  void *result = NULL;    va_list va;  va_start(va, cmd);  switch(cmd)  {    case ESDIF_UNIT_CMD_NAME:      result = "random function linear interpolation test 1";      break;    case ESDIF_UNIT_CMD_RUN:      result = (void *)doTest(unit_LinearInterpolator1);      break;  }    va_end(va);    return result;}void *unit_randomLinear2(SDIFunitCmd cmd, ...){  void *result = NULL;    va_list va;  va_start(va, cmd);  switch(cmd)  {    case ESDIF_UNIT_CMD_NAME:      result = "random function linear interpolation test 2";      break;    case ESDIF_UNIT_CMD_RUN:      result = (void *)doTest(unit_LinearInterpolator2);      break;  }    va_end(va);    return result;}static SDIFresult doTest(SDIFinterp_InterpolatorFn interpFn){  SDIFresult r;  int i;    //  run the test repeatedly  //  (random parameters should exercise a variety of unusual cases)  for(i = 0; i < 100; i++)  {    unit_log(LOG_RESULTS, "starting run %d\n", i);    if(ESDIF_SUCCESS != (r = doOneTest(interpFn)))    {      unit_log(LOG_ERROR, "failed on run %d\n", i);      break;    }  }    return r;}static SDIFresult doOneTest(SDIFinterp_InterpolatorFn interpFn){  SDIFresult r;  SDIFbuf_Buffer buf;  SDIFinterp_Interpolator it;  //  initialize collection of random times  //  (use limited set of times so we exercise a variety of exact time match/collision cases)  randomTimeInit();    //  create a buffer  //  add a bunch of random values at random times  if(!(buf = createRandomFunctionBuffer()))    return ESDIF_OUT_OF_MEMORY;    //  add a bunch of empty frames at other random times  if(ESDIF_SUCCESS != (r = addJunkToBuffer(buf, NUM_FRAMES)))    return r;    //  create an interpolator  if(!(it = createInterpolator(interpFn)))  {    SDIFbuf_Free(buf);    return ESDIF_OUT_OF_MEMORY;  }  //  interpolate the random function buffer 2 different ways, compare results  r = doInterpolatorTest(buf, it);  //  release the buffer + interpolator  SDIFbuf_Free(buf);  SDIFinterp_Free(it);    return r;}static SDIFresult doInterpolatorTest(SDIFbuf_Buffer buf, SDIFinterp_Interpolator it){  int i, j;  sdif_float64 t, prevTime;    //  compute interpolated samples at regular intervals  //  1. do it the long way  //  2. do it through SDIFinterp_Interpolator instance  //  3. compare results  for(t = 0; t < FUN_DOMAIN; t += 10)  {    SDIFmem_Matrix m1, m2, mCheck, mInterp;    sdif_float64 t1, t2;        //  do linear interpolation per cell    if(!(mCheck = SDIFutil_CreateMatrix(NUM_COLUMNS, NUM_ROWS, SDIF_FLOAT64, "----")))      return ESDIF_OUT_OF_MEMORY;        unit_log(LOG_INFO2, "***time=%f\n\n", t);        if(!(m1 = SDIFbuf_GetMatrix(buf, "----", t, ESDIF_SEARCH_BACKWARDS, &t1)))      unit_log(LOG_INFO, "t1 = N/A\n");        if(!(m2 = SDIFbuf_GetMatrix(buf, "----", t, ESDIF_SEARCH_FORWARDS, &t2)))      unit_log(LOG_INFO, "t2 = N/A\n");    if(t == t1)    {      //  found an exact matching time        for(i = 0; i < NUM_ROWS; i++)          for(j = 0; j < NUM_COLUMNS; j++)            //  linear interpolation code is in unit_FunctionValue()            SDIFutil_SetMatrixCell(mCheck, j, i, SDIFutil_GetMatrixCell(m1, j, i));    }    else      //  we need to interpolate      if(m1 && m2)      {        unit_log(LOG_INFO, "pass 1: time = %f, t1 = %f, t2 = %f\n", t, t1, t2);        unit_assert(t1 < t2, "@interpolate pass 1: frame locate failure\n");        unit_assert(t >= t1, "@interpolate pass 1: frame locate failure\n");        unit_assert(t < t2, "@interpolate pass 1: frame locate failure\n");        unit_PrintMatrix(LOG_INFO2, m1);        unit_log(LOG_INFO2, "\n");        unit_PrintMatrix(LOG_INFO2, m2);        unit_log(LOG_INFO2, "\n");        unit_log(LOG_INFO2, "time=%f\n", t);        for(i = 0; i < NUM_ROWS; i++)          for(j = 0; j < NUM_COLUMNS; j++)            //  NOTE: linear interpolation code is in unit_FunctionValue()            SDIFutil_SetMatrixCell(mCheck, j, i, interpolateOneCell(buf, "----", j, i, t));        unit_PrintMatrix(LOG_INFO2, mCheck);        unit_log(LOG_INFO, "\n");      }    //  now do the same thing using SDIFinterp_Interpolator    mInterp = doInterpolate(it, buf, "----", t);        //  compare results    unit_assert(((mInterp && (m1 && m2)) || (!mInterp && (!m1 || !m2))),                "@failed existence check\n"                );    if(mInterp)      unit_assert(SDIFutil_MatrixEqual(mInterp, mCheck), "@failed matrix match check\n");        //  clean up    SDIFmem_FreeMatrix(mCheck);    if(mInterp)      SDIFmem_FreeMatrix(mInterp);  }    return ESDIF_SUCCESS;}static SDIFbuf_Buffer createRandomFunctionBuffer(){  SDIFbuf_Buffer buf;  SDIFmem_Frame f;  int i;  sdif_float64 prevTime;  int numUniqueFrames;    if(!(buf = SDIFbuf_Create()))    return NULL;    //  make a random function (i.e. choose some random values at random times)  numUniqueFrames = createRandomFunction(buf,                                          NUM_FRAMES,                                          "----",                                          "----",                                          NUM_COLUMNS,                                          NUM_ROWS,                                          FUN_DOMAIN                                         );  if(numUniqueFrames == 0)    //  something bad happened    return NULL;  unit_log(LOG_INFO,           "generated random matrix values at these times (count = %d):\n",           numUniqueFrames           );  //  check buffer for correct number of frames and correct (increasing) time order  for(f = SDIFbuf_GetFirstFrame(buf), i = 0, prevTime = -1; f; f = SDIFbuf_GetNextFrame(f), i++)  {    unit_log(LOG_INFO, "%f\n", f->header.time);    unit_assert(f->header.time > prevTime, "@SDIFbuf_Buffer: inserted frames out of sequence\n");    prevTime = f->header.time;  }  unit_log(LOG_INFO, "\n");  unit_assert(i == numUniqueFrames, "@SDIFbuf_Buffer: inserted frames missing\n");    return buf;}static int createRandomFunction(SDIFbuf_Buffer b,                                sdif_int32 numFrames,                                const char *frameType,                                const char *matrixType,                                sdif_int32 columns,                                sdif_int32 rows,                                sdif_float64 functionDomain                                ){  SDIFresult r;  int i, j, k;  SDIFmem_Frame f;  SDIFmem_Matrix m;  int uniqueFramesAdded;    for(i = 0, uniqueFramesAdded = 0; i < numFrames; i++)  {    //  create a frame at a random time on functionDomain    if(!(f = SDIFmem_CreateEmptyFrame()))      break;    SDIF_Copy4Bytes(f->header.frameType, frameType);    f->header.time = randomTime();    unit_log(LOG_INFO2, "%f\n", f->header.time);        //  create a matrix, add to frame    if(!(m = SDIFutil_CreateMatrix(columns, rows, SDIF_FLOAT64, matrixType)))      break;    if(ESDIF_SUCCESS != (r = SDIFmem_AddMatrix(f, m)))      break;        //  fill in the matrix with random data    for(j = 0; j < rows; j++)      for(k = 0; k < columns; k++)        SDIFutil_SetMatrixCell(m, k, j, rand() / (sdif_float64)RAND_MAX);        //  add frame to buffer    r = SDIFbuf_InsertFrame(b, f, ESDIF_INSERT_DONT_REPLACE);    if(r == ESDIF_SUCCESS)      uniqueFramesAdded++;      continue;    if(r == ESDIF_FRAME_ALREADY_EXISTS)      continue;    else      break;  }  if(i != numFrames)    //  something bad happened    return 0;    return uniqueFramesAdded;}static SDIFresult addJunkToBuffer(SDIFbuf_Buffer buf, int junkCount){  int i;  SDIFresult r;    for(i = 0, r = ESDIF_SUCCESS; i < junkCount; i++)  {    SDIFmem_Frame f = SDIFmem_CreateEmptyFrame();    if(!f)      return ESDIF_OUT_OF_MEMORY;    f->header.time = randomTime();    SDIF_Copy4Bytes(f->header.frameType, "----");        r = SDIFbuf_InsertFrame(buf, f, ESDIF_INSERT_DONT_REPLACE);    if((r != ESDIF_SUCCESS) && (r != ESDIF_FRAME_ALREADY_EXISTS))      return r;  }    return ESDIF_SUCCESS;}static void randomTimeInit(void){  int i;    for(i = 0; i < NUM_RANDOM_TIMES; i++)    randomTimeList[i] = rand() % FUN_DOMAIN;}static sdif_float64 randomTime(void){  return randomTimeList[(NUM_RANDOM_TIMES * rand()) / (RAND_MAX + 1)];}////  do linear interpolation without using sdif-interp.c//static sdif_float64 interpolateOneCell(SDIFbuf_Buffer buf,                                const char *matrixType,                                sdif_int32 column,                                sdif_int32 row,                                sdif_float64 time                                ){  SDIFmem_Frame f;  SDIFmem_Matrix m1, m2;  sdif_float64 t1, t2, f1, f2;    if(!(f = SDIFbuf_GetFirstFrame(buf)))    return -1;  //  in a real app, would need to signal errors some other way!                //  (but caller already checked to make sure we have previous + next data)  if(!(m1 = SDIFbuf_GetMatrixNearby(f, matrixType, time, ESDIF_SEARCH_BACKWARDS, &t1)))    return -1;    if(!(m2 = SDIFbuf_GetMatrixNearby(f, matrixType, time, ESDIF_SEARCH_FORWARDS, &t2)))    return -1;  f1 = SDIFutil_GetMatrixCell(m1, column, row);  f2 = SDIFutil_GetMatrixCell(m2, column, row);  return ((time - t1) * (f2 - f1) / (t2 - t1)) + f1;}////  do linear interpolation using sdif-interp.c//static SDIFmem_Matrix doInterpolate(SDIFinterp_Interpolator it,                                     SDIFbuf_Buffer b,                                    const char *matrixType,                                    sdif_float64 time                                    ){  SDIFmem_Matrix matrixOut;  if(!(matrixOut = SDIFutil_CreateMatrix(NUM_COLUMNS, NUM_ROWS, SDIF_FLOAT64, "----")))    return NULL;      if(ESDIF_SUCCESS != SDIFinterp_GetMatrix(it,                                            b,                                            matrixType,                                            time,                                            ESDIF_NAN_ACTION_FAIL,                                           matrixOut                                           ))  {    SDIFmem_FreeMatrix(matrixOut);    return NULL;  }    return matrixOut;}////  prepare interpolator instance//static SDIFinterp_Interpolator createInterpolator(SDIFinterp_InterpolatorFn interpFn){  SDIFinterp_Interpolator it;    if(!(it = SDIFinterp_Create(NUM_COLUMNS)))    return NULL;    if(ESDIF_SUCCESS != SDIFinterp_SetAllInterpolatorFn(it, interpFn))    return NULL;    return it;}////  linear interpolator (example 1: without NaN handling)//static SDIFresult unit_LinearInterpolator1(SDIFmem_Frame nearbyFrame,                                           const char *matrixType,                                           sdif_int32 column,                                           sdif_float64 time,                                           SDIFactionOnNaN actionOnNaN,                                           SDIFmem_Matrix matrixOut,                                           va_list args                                           ){  int rows = matrixOut->header.rowCount;  int i;    SDIFmem_Matrix m1, m2;  sdif_float64 t1, t2;    m1 = SDIFbuf_GetMatrixNearby(nearbyFrame,                               matrixType,                               time,                               ESDIF_SEARCH_BACKWARDS,                               &t1                               );    if(time == t1)  {    //  exact time match    for(i = 0; i < matrixOut->header.rowCount; i++)      SDIFutil_SetMatrixCell(matrixOut, column, i, SDIFutil_GetMatrixCell(m1, column, i));  }  else  {    //  need to interpolate    m2 = SDIFbuf_GetMatrixNearby(nearbyFrame,                                 matrixType,                                 time,                                 ESDIF_SEARCH_FORWARDS,                                 &t2                                 );        if(m1 && m2)    {      if(column == 0)        unit_log(LOG_INFO, "pass 2: time = %f, t1 = %f, t2 = %f\n", time, t1, t2);      unit_assert(t1 < t2, "@interpolate pass 2: frame locate failure\n");      unit_assert(time >= t1, "@interpolate pass 2: frame locate failure\n");      unit_assert(time < t2, "@interpolate pass 2: frame locate failure\n");            for(i = 0; i < matrixOut->header.rowCount; i++)      {        sdif_float64 v1 = SDIFutil_GetMatrixCell(m1, column, i);        sdif_float64 v2 = SDIFutil_GetMatrixCell(m2, column, i);        SDIFutil_SetMatrixCell(matrixOut, column, i, v1 + ((time - t1) * (v2 - v1) / (t2 - t1)));      }    }    else      return ESDIF_NOT_AVAILABLE;  }    return ESDIF_SUCCESS;}////  linear interpolator (example 2: includes NaN handling)//static SDIFresult unit_LinearInterpolator2(SDIFmem_Frame nearbyFrame,                                           const char *matrixType,                                           sdif_int32 column,                                           sdif_float64 time,                                           SDIFactionOnNaN actionOnNaN,                                           SDIFmem_Matrix matrixOut,                                           va_list args                                           ){  SDIFresult r;  int rows = matrixOut->header.rowCount;  int i;    //  loop to compute value for this column in each row  for(i = 0; i < matrixOut->header.rowCount; i++)  {    sdif_float64 t1, t2, v1, v2;    //  first attempt to find value at requested time    r = SDIFbuf_GetValueNearby(nearbyFrame,                               matrixType,                               column,                               i,                               time,                               ESDIF_SEARCH_BACKWARDS,                               actionOnNaN,                               &v1,                               &t1                               );    if(r != ESDIF_SUCCESS)      //  failed: couldn't find value at or before requested time      return r;        if(time == t1)      //  exact time match found, no need to interpolate      SDIFutil_SetMatrixCell(matrixOut, column, i, v1);        else    {      //  need to interpolate, so we need a second value      r = SDIFbuf_GetValueNearby(nearbyFrame,                                 matrixType,                                 column,                                 i,                                 time,                                 ESDIF_SEARCH_FORWARDS,                                 actionOnNaN,                                 &v2,                                 &t2                                 );      if(r != ESDIF_SUCCESS)        //  failed: couldn't find value after requested time        return r;      //  success: do linear interpolation      SDIFutil_SetMatrixCell(matrixOut, column, i, v1 + ((time - t1) * (v2 - v1) / (t2 - t1)));    }  }    return ESDIF_SUCCESS;}